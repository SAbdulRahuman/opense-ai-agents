package agent

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"github.com/seenimoa/openseai/internal/agent/prompts"
	"github.com/seenimoa/openseai/internal/llm"
	"github.com/seenimoa/openseai/pkg/models"
)

// ReporterAgent is the Report Generator specialized agent.
// It synthesizes analysis from multiple agents into a professional equity research report.
type ReporterAgent struct {
	*BaseAgent
}

// NewReporterAgent creates a Report Generator agent.
func NewReporterAgent(provider llm.LLMProvider, opts *llm.ChatOptions) *ReporterAgent {
	agent := &ReporterAgent{}

	tools := agent.buildTools()

	systemPrompt := prompts.ReporterSystemPrompt + prompts.IndianMarketPromptSuffix()

	agent.BaseAgent = NewBaseAgent(BaseAgentConfig{
		Name:         prompts.AgentReporter,
		Role:         "Report Generator — Equity research report synthesis",
		SystemPrompt: systemPrompt,
		Provider:     provider,
		Tools:        tools,
		ChatOptions:  opts,
		MemorySize:   50, // larger memory for report context
		MaxToolIter:  4,
	})

	return agent
}

func (a *ReporterAgent) buildTools() []llm.Tool {
	return []llm.Tool{
		{
			Name:        "format_report",
			Description: "Format a structured equity research report from analysis inputs",
			Parameters: llm.ObjectSchema("Report formatting parameters",
				map[string]*llm.JSONSchema{
					"ticker":         llm.StringProp("NSE ticker symbol"),
					"title":          llm.StringProp("Report title"),
					"sections":       llm.ArrayProp("Report sections in order", llm.ObjectSchema("Section",
						map[string]*llm.JSONSchema{
							"heading": llm.StringProp("Section heading"),
							"content": llm.StringProp("Section content in markdown"),
						},
						"heading", "content",
					)),
					"recommendation": llm.StringProp("Overall recommendation: STRONG BUY, BUY, HOLD, SELL, STRONG SELL"),
					"target_price":   llm.NumberProp("Target price in ₹"),
					"stop_loss":      llm.NumberProp("Stop-loss price in ₹"),
					"timeframe":      llm.StringProp("Investment timeframe: intraday, short-term, medium-term, long-term"),
				},
				"ticker", "recommendation",
			),
			Handler: a.handleFormatReport,
		},
		{
			Name:        "create_summary_table",
			Description: "Create a comparison/summary table from analysis data",
			Parameters: llm.ObjectSchema("Table parameters",
				map[string]*llm.JSONSchema{
					"title":   llm.StringProp("Table title"),
					"headers": llm.ArrayProp("Column headers", llm.StringProp("Header")),
					"rows":    llm.ArrayProp("Table rows", llm.ArrayProp("Row values", llm.StringProp("Cell"))),
				},
				"title", "headers", "rows",
			),
			Handler: a.handleCreateTable,
		},
	}
}

// ── Tool Handlers ──

func (a *ReporterAgent) handleFormatReport(_ context.Context, args json.RawMessage) (string, error) {
	var params struct {
		Ticker         string `json:"ticker"`
		Title          string `json:"title"`
		Sections       []struct {
			Heading string `json:"heading"`
			Content string `json:"content"`
		} `json:"sections"`
		Recommendation string  `json:"recommendation"`
		TargetPrice    float64 `json:"target_price"`
		StopLoss       float64 `json:"stop_loss"`
		Timeframe      string  `json:"timeframe"`
	}
	if err := json.Unmarshal(args, &params); err != nil {
		return "", fmt.Errorf("parse args: %w", err)
	}

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("# %s\n\n", params.Title))
	sb.WriteString(fmt.Sprintf("**Ticker:** %s | **Date:** %s\n\n", params.Ticker, time.Now().Format("02 Jan 2006")))

	// Recommendation badge
	sb.WriteString(fmt.Sprintf("## Recommendation: %s\n\n", params.Recommendation))
	if params.TargetPrice > 0 {
		sb.WriteString(fmt.Sprintf("**Target Price:** ₹%.2f", params.TargetPrice))
		if params.StopLoss > 0 {
			sb.WriteString(fmt.Sprintf(" | **Stop-Loss:** ₹%.2f", params.StopLoss))
		}
		if params.Timeframe != "" {
			sb.WriteString(fmt.Sprintf(" | **Timeframe:** %s", params.Timeframe))
		}
		sb.WriteString("\n\n")
	}

	sb.WriteString("---\n\n")

	// Sections
	for _, sec := range params.Sections {
		sb.WriteString(fmt.Sprintf("## %s\n\n%s\n\n", sec.Heading, sec.Content))
	}

	// Disclaimer
	sb.WriteString("---\n\n")
	sb.WriteString("*Disclaimer: This report is generated by OpeNSE.ai for educational purposes only. ")
	sb.WriteString("It does not constitute financial advice. Please consult a SEBI-registered advisor before making investment decisions.*\n")

	return sb.String(), nil
}

func (a *ReporterAgent) handleCreateTable(_ context.Context, args json.RawMessage) (string, error) {
	var params struct {
		Title   string     `json:"title"`
		Headers []string   `json:"headers"`
		Rows    [][]string `json:"rows"`
	}
	if err := json.Unmarshal(args, &params); err != nil {
		return "", fmt.Errorf("parse args: %w", err)
	}

	var sb strings.Builder

	if params.Title != "" {
		sb.WriteString(fmt.Sprintf("### %s\n\n", params.Title))
	}

	if len(params.Headers) == 0 {
		return "No headers provided for table", nil
	}

	// Header row
	sb.WriteString("| ")
	for _, h := range params.Headers {
		sb.WriteString(h + " | ")
	}
	sb.WriteString("\n")

	// Separator
	sb.WriteString("| ")
	for range params.Headers {
		sb.WriteString("--- | ")
	}
	sb.WriteString("\n")

	// Data rows
	for _, row := range params.Rows {
		sb.WriteString("| ")
		for i, cell := range row {
			if i < len(params.Headers) {
				sb.WriteString(cell + " | ")
			}
		}
		sb.WriteString("\n")
	}

	return sb.String(), nil
}

// GenerateReport produces an equity research report from multiple analysis results.
func (a *ReporterAgent) GenerateReport(ctx context.Context, ticker string, analyses []*AgentResult) (*AgentResult, error) {
	// Build report input from all analyses
	task := fmt.Sprintf(
		"Generate a comprehensive equity research report for %s based on the following analysis from our team.\n\n"+
			"%s\n\n",
		ticker, prompts.FormatTickerPrompt(ticker),
	)

	for _, ar := range analyses {
		if ar != nil && ar.Content != "" {
			task += fmt.Sprintf("### %s (%s)\n%s\n\n", ar.AgentName, ar.Role, ar.Content)
		}
	}

	task += "Synthesize all analyses into a professional report with:\n" +
		"1. Executive Summary\n" +
		"2. Technical Analysis Summary\n" +
		"3. Fundamental Overview\n" +
		"4. F&O / Derivatives View\n" +
		"5. Sentiment Analysis\n" +
		"6. Risk Assessment\n" +
		"7. Overall Recommendation (STRONG BUY / BUY / HOLD / SELL / STRONG SELL)\n" +
		"8. Trade Setup (entry, target, stop-loss, timeframe)\n\n" +
		"Use Indian number formatting (₹, Lakhs, Crores). Be objective, highlight conflicts between indicators."

	return a.Process(ctx, task)
}

// AnalyzeWithTimestamp generates a report and attaches typed result metadata.
func (a *ReporterAgent) AnalyzeWithTimestamp(ctx context.Context, ticker string, analyses []*AgentResult) (*AgentResult, error) {
	result, err := a.GenerateReport(ctx, ticker, analyses)
	if err != nil {
		return result, err
	}

	result.Analysis = ParseAnalysisResult(result.Content, models.AnalysisResult{
		Ticker:    ticker,
		Type:      models.AnalysisComposite,
		AgentName: a.Name(),
		Timestamp: time.Now(),
	})

	return result, nil
}
